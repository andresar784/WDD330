<!doctype html>
<html>
<head>
<title>Week 10 Notes</title>
    <meta charset="UTF-8" />
    <meta name="author" content="Andres Rodriguez Peinado" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
   
</head>
<body>
    <div class="container-fluid">
        <h3>Week 10 Notes</h3>
        <h4>Client-side form validation</h4>
        <p>Before submitting data to the server, it is important to ensure all required form controls are filled out, in the correct format. This is called client-side form validation, 
            and helps ensure data submitted matches the requirements set forth in the various form controls</p>
        <p>Client-side validation is an initial check and an important feature of good user experience; 
            by catching invalid data on the client-side, the user can fix it straight away.</p>
            <p> When you enter data, the browser and/or the web server will check to see that the data is in the 
                correct format and within the constraints set by the application. Validation done in the browser is called client-side validation, 
                while validation done on the server is called server-side validation</p>
            <p>If the information is correctly formatted, the application allows the data to be submitted to the server and (usually) saved in a database; if the information 
                isn't correctly formatted, it gives the user an error message explaining what needs to be corrected, and lets them try again.</p>
            <p>We want to make filling out web forms as easy as possible. So why do we insist on validating our forms? There are three main reasons:</p>
            <ul>
                <li><b>We want to get the right data, in the right format.</b> Our applications won't work properly if our users' data is stored in the wrong format, is incorrect, or is omitted altogether.</li>
                <li><b>We want to protect our users' data.</b> Forcing our users to enter secure passwords makes it easier to protect their account information.</li>
                <li><b>We want to protect ourselves.</b> There are many ways that malicious users can misuse unprotected forms to damage the application.</li>
            </ul>
        <h5>Using built-in form validation</h5>
        <p>Built-in form validation uses HTML5 form validation features, which we've discussed in many places throughout this module. This validation generally doesn't require much JavaScript. 
            Built-in form validation has better performance than JavaScript, but it is not as customizable as JavaScript validation.</p>
        <p>One of the most significant features of HTML5 form controls is the ability to validate most user data without relying on JavaScript.
             This is done by using validation attributes on form elements</p>
        <ul>
            <li><b><em>required: </em></b> Specifies whether a form field needs to be filled in before the form can be submitted.</li>
            <li><b><em>minlength</em></b> and <b><em>maxlength:</em></b> Specifies the minimum and maximum length of textual data (strings).</li>
            <li><b><em>min</em></b> and <b><em> max: </em></b> Specifies the minimum and maximum values of numerical input types.</li>
            <li><b><em>type: </em></b>Specifies whether the data needs to be a number, an email address, or some other specific preset type.</li>
            <li><b><em>pattern: </em></b> Specifies a regular expression that defines a pattern the entered data needs to follow.</li>
        </ul>
        <p>When an element is valid, the following thing are true: </p>
        <p>The element matches the :valid CSS pseudo-class, which lets you apply a specific style to valid elements.</p>
        <p>When an element is invalid, the followinf thing are true: </p>
        <p>The element matches the :invalid CSS pseudo-class, and sometimes other UI pseudo-classes (e.g., :out-of-range)
             depending on the error, which lets you apply a specific style to invalid elements.</p>
        <h6>Some examples.</h6>
        <form>
            <label >Would you prefer meat or fish?</label>
            <input  required pattern="[mM]eat|[Ff]ish">
            <button class="btn btn-success">Submit</button>
          </form>
          <h6>This example used:</h6>
          <p>Required, The simplest HTML5 validation feature is the required attribute. To make an input mandatory, 
              add this attribute to the element. When this attribute is set, the element matches the :required UI 
              pseudo-class and the form won't submit, displaying an error message on submission when the input is empty. 
              While empty, the input will also be considered invalid, matching the :invalid UI pseudo-class.</p>
        <p>A regular expression, Another useful validation feature is the pattern attribute, which expects a Regular Expression as its value. A regular expression (regex) is a pattern that can be used to
             match character combinations in text strings, so regexps are ideal for form validation and serve a variety of 
             other uses in JavaScript.</p>
             <form>
            <label>Enter a word of minimum of 6 letters and maximum of 8..</label>
            <input type="text" minlength="6" maxlength="8">
        </form>
        <h6>This example used:</h6>
        <p>minlength. The minlength attribute defines the minimum number of characters (as UTF-16 code units) the user can enter into an input or textarea. 
            This must be an integer value 0 or higher.
             If no minlength is specified, or an invalid value is specified, the input has no minimum length.</p>
        <p>maxlength. The maxlength attribute defines the maximum number of characters (as UTF-16 code units) the user can enter into an input or textarea. This must be an integer v
            alue 0 or higher.Any maxlength value must be greater than or equal to the value of minlength, if present and valid. 
            The input will fail constraint validation if the length of the text value of the field is greater than maxlength UTF-16 code units long. 
            Constraint validation is only applied when the value is changed by the user.</p> 
            <label for="number">How many would you like?</label>
            <input type="number" value="1" min="1" max="10">
            <h6>This example used:</h6>
            <p>For number fields (i.e. input type="number"), the min and max attributes
                 can be used to provide a range of valid values. If the field contains a value outside this range, it will be invalid.</p> 
            <p>Entered numbers outside this range will show as invalid; users won't be able to use the increment/decrement arrows to move the value outside of this range. If the user manually enters a number outside of this range,
                 the data is invalid. The number is not required, so removing the value will still result in a valid value.</p>        
        <h5>Validating forms using JavaScript</h5>        
         <p>You must use JavaScript if you want to take control over the look and feel of native error messages or to deal with 
             legacy browsers that do not support HTML's built-in form validation.</p>
        <h6>The Constraint Validation API</h6>
        <p>Most browsers support the Constraint Validation API, which consists of a set of methods and properties available on the following form element DOM interfaces:</p>
            <ul>
                <li>HTMLButtonElement (represents a button element)</li>
                <li>HTMLFieldSetElement (represents a fieldset element)</li>
                <li>HTMLInputElement (represents an input element)</li>
                <li>HTMLOutputElement (represents an output element)</li>
                <li>HTMLSelectElement (represents a select element)</li>
                <li>HTMLTextAreaElement (represents a textarea element)</li>
            </ul>
        <p>The Constraint validation API makes the following properties available on the above elements.</p>
        <p>validationMessage: Returns a localized message describing the validation constraints that the control doesn't satisfy (if any).</p>
        <p>validity: Returns a ValidityState object that contains several properties describing the validity state of the element.</p>
        <p><em>patternMismatch:</em> Returns true if the value does not match the specified pattern, and false if it does match</p>
        <p><em>tooLong: </em> Returns true if the value is longer than the maximum length specified by the maxlength attribute, 
            or false if it is shorter than or equal to the maximum. </p>
        <p><em>tooShort:</em> Returns true if the value is shorter than the minimum length specified by the minlength attribute, or false if it is greater than or equal to the minimum.</p>
        <p><em>rangeOverflow:</em> Returns true if the value is greater than the maximum specified by the max attribute, or false if it is less than or equal to the maximum</p>
        <p><em>rangeUnderflow: </em> Returns true if the value is less than the minimum specified by the min attribute, or false if it is greater than or equal to the minimum.</p>
        <p><em>typeMismatch: </em> Returns true if the value is not in the required syntax (when type is email or url), or false if the syntax is correct.</p>
        <p><em>valid: </em> Returns true if the element meets all its validation constraints, and is therefore considered to be valid, or false if it fails any constraint. </p>
        <p><em>valueMissing: </em> Returns true if the element has a required attribute, but no value, or false otherwise.</p>
        <h6>Example of using JavaScript validation.</h6>
        <p></p>
        <form>
            <label for="mail">I would like you to provide me with an e-mail address:</label>
            <input type="email" id="mail" name="mail">
            <button class="btn btn-success">Submit</button>
        </form>
        <p>Here we store a reference to the email input, then add an event listener to it that runs
             the contained code each time the value inside the input is changed. Inside the contained code, we check whether the email input's validity.typeMismatch property returns true, meaning that the contained
              value doesn't match the pattern for a well-formed email address. If so, we call the setCustomValidity() method with a custom message. </p>
        <p></p>
        <form>
            <p>
              <label for="mail">
                <span>Please enter an email address:</span>
                <input type="email" id="mail2" name="mail2" required minlength="8">
                <span class="error" aria-live="polite"></span>
              </label>
            </p>
            <button class="btn btn-success"> Submit</button>
          </form>
          <p>This simple form uses the novalidate attribute to turn off the browser's automatic validation; this lets our script take control over validation</p>
          <p></p>
          
    </div>
    <div class="container-fluid">
        <h4>Using Fetch</h4>
        <p>The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. 
            It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.</p>
        <p>A basic fetch request is really simple to set up. Have a look at the following code:</p>
        <p><pre>fetch('http://example.com/movies.json')
            .then(response => response.json())
            .then(data => console.log(data));
          </pre></p>
        <p>Here we are fetching a JSON file across the network and printing it to the console. The simplest use of fetch() takes one argument — the path to the resource you want
        to fetch — and does not directly return the JSON response body but instead returns a promise that resolves with a Response object.</p>
        <p>The Response object, in turn, does not directly contain the actual JSON response body but is instead a representation of the entire HTTP response. So, to extract the JSON body content from the Response object,
             we use the json() method, which returns a second promise that resolves with the result of parsing the response body text as JSON.</p>
        <p></p>
    </div>

    <div class="container p-3 my-3 bg-dark text-white">
        <a href="quakes\earthquake.html">Earthquake near of me activity</a>
    </div>

<script type="text/javascript" src="main.js"></script>
</body>
</html>